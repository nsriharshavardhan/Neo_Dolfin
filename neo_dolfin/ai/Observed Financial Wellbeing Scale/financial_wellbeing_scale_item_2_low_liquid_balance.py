# -*- coding: utf-8 -*-
"""Financial Wellbeing Scale - Item 2: Low Liquid Balance

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kjh3evyyCd_jucNqXAJ1j_jpw4Z95puA
"""

import pandas as pd

def llb(csv_path):
    # Load CSV into DataFrame
    account_df = pd.read_csv(csv_path)

    # Check and adjust column names if necessary
    if 'Description' not in account_df.columns:
        if 'Transaction Details' in account_df.columns:
            account_df.rename(columns={'Transaction Details': 'Description'}, inplace=True)
        else:
            print("Warning: 'Description' column not found.")
            return None

    # Convert Amount and Balance column to numeric
    account_df['Amount'] = pd.to_numeric(account_df['Amount'], errors='coerce')
    account_df['Balance'] = pd.to_numeric(account_df['Balance'], errors='coerce')

    # Ensure 'Date' column is datetime
    if 'Date' in account_df.columns:
        account_df['Date'] = pd.to_datetime(account_df['Date'])

    # Select only relevant columns
    account_df = account_df[['Date', 'Amount', 'Description', 'Balance']]

    # Filter dataframe for negative values, and exclude any Transfers
    expenses_df = account_df[account_df['Amount'] < 0] \
                    .loc[~account_df['Description'].str.contains('Transfer')] \
                    .copy().reset_index(drop=True)

    # Group by week and calculate the sum of expenses
    weekly_expenses = expenses_df.groupby(pd.Grouper(key='Date', freq='W'))['Amount'].sum()

    # Calculate the average of the weekly expenses
    average_expenses = weekly_expenses.mean()

    # Create a date range with every singular date between the min and max dates in the original DataFrame
    min_date_original = account_df['Date'].min()
    max_date_original = account_df['Date'].max()
    full_date_range = pd.date_range(start=min_date_original, end=max_date_original)

    # Create a DataFrame with the full range of dates
    full_date_df = pd.DataFrame({'Date': full_date_range})

    # Merge the full date DataFrame with the original DataFrame using 'outer' join on Date to retain all rows
    merged_df = pd.merge(full_date_df, account_df, on='Date', how='outer')

    # Remove rows with duplicate dates and retain only the last row for each unique date
    merged_df.drop_duplicates(subset='Date', keep='last', inplace=True)

    # Sort the DataFrame by date
    merged_df.sort_values(by='Date', inplace=True)

    # Fill NaN values in the 'Balance' column with the previous non-NaN value
    merged_df['Balance'].fillna(method='ffill', inplace=True)

    # Add a new column 'Above Weekly Expenses' and set its value based on the condition
    merged_df['Above Weekly Expenses'] = (merged_df['Balance'] > average_expenses).astype(int)

    # Calculate total number of days in the total range
    total_days = merged_df['Date'].nunique()

    # Calculate number of 0's in the 'Above Weekly Expenses' column
    days_below_average = (merged_df['Above Weekly Expenses'] == 0).sum()

    # Calculate the percentage of days below average weekly expenses
    percentage_below_average = (days_below_average / total_days) * 100

    # Assign a score based on the percentage below average weekly expenses
    if percentage_below_average >= 75:
        low_liquid_balance = 0
    elif 50 <= percentage_below_average < 75:
        low_liquid_balance = 1
    elif 10 <= percentage_below_average < 50:
        low_liquid_balance = 2
    elif percentage_below_average == 0:  # Adjusted this condition
        low_liquid_balance = 4  # Assigning score 4
    else:
        low_liquid_balance = 3

    return {
        'low_liquid_balance': low_liquid_balance
    }

# Get Low Liquid Balance for Product
results = llb('credit_card.csv')
print(results)